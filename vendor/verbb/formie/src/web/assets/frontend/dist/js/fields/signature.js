/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/fields/signature.js":
/*!************************************!*\
  !*** ./src/js/fields/signature.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormieSignature\": () => (/* binding */ FormieSignature)\n/* harmony export */ });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"./src/js/utils/utils.js\");\n/* harmony import */ var signature_pad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! signature_pad */ \"../../../../node_modules/signature_pad/dist/signature_pad.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\nvar FormieSignature = /*#__PURE__*/function () {\n  function FormieSignature() {\n    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, FormieSignature);\n\n    this.$form = settings.$form;\n    this.form = this.$form.form;\n    this.$field = settings.$field;\n    this.$input = this.$field.querySelector('input');\n    this.$canvas = this.$field.querySelector('canvas');\n    this.$clearBtn = this.$field.querySelector('[data-signature-clear]');\n    this.backgroundColor = settings.backgroundColor;\n    this.penColor = settings.penColor;\n    this.penWeight = settings.penWeight;\n\n    if (this.$canvas) {\n      this.initPad();\n    } else {\n      console.error('Unable to find canvas.');\n    }\n  }\n\n  _createClass(FormieSignature, [{\n    key: \"initPad\",\n    value: function initPad() {\n      var _this = this;\n\n      this.signaturePad = new signature_pad__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.$canvas, {\n        backgroundColor: this.backgroundColor,\n        penColor: this.penColor,\n        dotSize: this.penWeight,\n        minWidth: this.penWeight,\n        maxWidth: this.penWeight\n      });\n      this.signaturePad.addEventListener('endStroke', function (e) {\n        // Save the data-url image for the server\n        _this.$input.value = _this.signaturePad.toDataURL();\n      }); // Clear the canvas\n\n      if (this.$clearBtn) {\n        this.$clearBtn.addEventListener('click', function () {\n          _this.signaturePad.clear();\n\n          _this.$input.value = '';\n        });\n      } // If the hidden input already has a value, we should use that. Normally captured\n      // during validation errors, or when editing an existing submission.\n\n\n      if (this.$input.value) {\n        var $img = document.createElement('img');\n        $img.src = this.$input.value;\n        this.signaturePad.clear();\n\n        $img.onload = function () {\n          // Handle retina devices\n          var ratio = Math.max(window.devicePixelRatio || 1, 1);\n\n          _this.$canvas.getContext('2d').drawImage($img, 0, 0, _this.$canvas.width / ratio, _this.$canvas.height / ratio);\n        };\n      } // Handle retina devices to properly scale things\n\n\n      window.addEventListener('resize', this.resizeCanvas);\n      this.resizeCanvas(); // For ajax forms, we want to refresh the field when the page is toggled\n      // for clicking on tabs, or for going to the next page. Canvas size will be tiny\n      // if hidden (the case for multi-page forms with this field on a later page).\n\n      if (this.form.settings.submitMethod === 'ajax') {\n        this.form.addEventListener(this.$form, 'onFormiePageToggle', function () {\n          // Supply a little delay so the DOM is ready\n          setTimeout(function () {\n            _this.resizeCanvas();\n          }, 100);\n        });\n      }\n    }\n  }, {\n    key: \"resizeCanvas\",\n    value: function resizeCanvas() {\n      if (this.$canvas) {\n        var ratio = Math.max(window.devicePixelRatio || 1, 1);\n        this.$canvas.width = this.$canvas.offsetWidth * ratio;\n        this.$canvas.height = this.$canvas.offsetHeight * ratio;\n        this.$canvas.getContext('2d').scale(ratio, ratio);\n        this.signaturePad.clear();\n      }\n    }\n  }]);\n\n  return FormieSignature;\n}();\nwindow.FormieSignature = FormieSignature;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvZmllbGRzL3NpZ25hdHVyZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUVBO0FBRU8sSUFBTUUsZUFBYjtFQUNJLDJCQUEyQjtJQUFBLElBQWZDLFFBQWUsdUVBQUosRUFBSTs7SUFBQTs7SUFDdkIsS0FBS0MsS0FBTCxHQUFhRCxRQUFRLENBQUNDLEtBQXRCO0lBQ0EsS0FBS0MsSUFBTCxHQUFZLEtBQUtELEtBQUwsQ0FBV0MsSUFBdkI7SUFDQSxLQUFLQyxNQUFMLEdBQWNILFFBQVEsQ0FBQ0csTUFBdkI7SUFDQSxLQUFLQyxNQUFMLEdBQWMsS0FBS0QsTUFBTCxDQUFZRSxhQUFaLENBQTBCLE9BQTFCLENBQWQ7SUFDQSxLQUFLQyxPQUFMLEdBQWUsS0FBS0gsTUFBTCxDQUFZRSxhQUFaLENBQTBCLFFBQTFCLENBQWY7SUFDQSxLQUFLRSxTQUFMLEdBQWlCLEtBQUtKLE1BQUwsQ0FBWUUsYUFBWixDQUEwQix3QkFBMUIsQ0FBakI7SUFFQSxLQUFLRyxlQUFMLEdBQXVCUixRQUFRLENBQUNRLGVBQWhDO0lBQ0EsS0FBS0MsUUFBTCxHQUFnQlQsUUFBUSxDQUFDUyxRQUF6QjtJQUNBLEtBQUtDLFNBQUwsR0FBaUJWLFFBQVEsQ0FBQ1UsU0FBMUI7O0lBRUEsSUFBSSxLQUFLSixPQUFULEVBQWtCO01BQ2QsS0FBS0ssT0FBTDtJQUNILENBRkQsTUFFTztNQUNIQyxPQUFPLENBQUNDLEtBQVIsQ0FBYyx3QkFBZDtJQUNIO0VBQ0o7O0VBbEJMO0lBQUE7SUFBQSxPQW9CSSxtQkFBVTtNQUFBOztNQUNOLEtBQUtDLFlBQUwsR0FBb0IsSUFBSWhCLHFEQUFKLENBQWlCLEtBQUtRLE9BQXRCLEVBQStCO1FBQy9DRSxlQUFlLEVBQUUsS0FBS0EsZUFEeUI7UUFFL0NDLFFBQVEsRUFBRSxLQUFLQSxRQUZnQztRQUcvQ00sT0FBTyxFQUFFLEtBQUtMLFNBSGlDO1FBSS9DTSxRQUFRLEVBQUUsS0FBS04sU0FKZ0M7UUFLL0NPLFFBQVEsRUFBRSxLQUFLUDtNQUxnQyxDQUEvQixDQUFwQjtNQVFBLEtBQUtJLFlBQUwsQ0FBa0JJLGdCQUFsQixDQUFtQyxXQUFuQyxFQUFnRCxVQUFDQyxDQUFELEVBQU87UUFDbkQ7UUFDQSxLQUFJLENBQUNmLE1BQUwsQ0FBWWdCLEtBQVosR0FBb0IsS0FBSSxDQUFDTixZQUFMLENBQWtCTyxTQUFsQixFQUFwQjtNQUNILENBSEQsRUFUTSxDQWNOOztNQUNBLElBQUksS0FBS2QsU0FBVCxFQUFvQjtRQUNoQixLQUFLQSxTQUFMLENBQWVXLGdCQUFmLENBQWdDLE9BQWhDLEVBQXlDLFlBQU07VUFDM0MsS0FBSSxDQUFDSixZQUFMLENBQWtCUSxLQUFsQjs7VUFDQSxLQUFJLENBQUNsQixNQUFMLENBQVlnQixLQUFaLEdBQW9CLEVBQXBCO1FBQ0gsQ0FIRDtNQUlILENBcEJLLENBc0JOO01BQ0E7OztNQUNBLElBQUksS0FBS2hCLE1BQUwsQ0FBWWdCLEtBQWhCLEVBQXVCO1FBQ25CLElBQU1HLElBQUksR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQWI7UUFDQUYsSUFBSSxDQUFDRyxHQUFMLEdBQVcsS0FBS3RCLE1BQUwsQ0FBWWdCLEtBQXZCO1FBRUEsS0FBS04sWUFBTCxDQUFrQlEsS0FBbEI7O1FBRUFDLElBQUksQ0FBQ0ksTUFBTCxHQUFjLFlBQU07VUFDaEI7VUFDQSxJQUFNQyxLQUFLLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxDQUFTQyxNQUFNLENBQUNDLGdCQUFQLElBQTJCLENBQXBDLEVBQXVDLENBQXZDLENBQWQ7O1VBRUEsS0FBSSxDQUFDMUIsT0FBTCxDQUFhMkIsVUFBYixDQUF3QixJQUF4QixFQUE4QkMsU0FBOUIsQ0FBd0NYLElBQXhDLEVBQThDLENBQTlDLEVBQWlELENBQWpELEVBQW9ELEtBQUksQ0FBQ2pCLE9BQUwsQ0FBYTZCLEtBQWIsR0FBcUJQLEtBQXpFLEVBQWdGLEtBQUksQ0FBQ3RCLE9BQUwsQ0FBYThCLE1BQWIsR0FBc0JSLEtBQXRHO1FBQ0gsQ0FMRDtNQU1ILENBcENLLENBc0NOOzs7TUFDQUcsTUFBTSxDQUFDYixnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxLQUFLbUIsWUFBdkM7TUFDQSxLQUFLQSxZQUFMLEdBeENNLENBMENOO01BQ0E7TUFDQTs7TUFDQSxJQUFJLEtBQUtuQyxJQUFMLENBQVVGLFFBQVYsQ0FBbUJzQyxZQUFuQixLQUFvQyxNQUF4QyxFQUFnRDtRQUM1QyxLQUFLcEMsSUFBTCxDQUFVZ0IsZ0JBQVYsQ0FBMkIsS0FBS2pCLEtBQWhDLEVBQXVDLG9CQUF2QyxFQUE2RCxZQUFNO1VBQy9EO1VBQ0FzQyxVQUFVLENBQUMsWUFBTTtZQUNiLEtBQUksQ0FBQ0YsWUFBTDtVQUNILENBRlMsRUFFUCxHQUZPLENBQVY7UUFHSCxDQUxEO01BTUg7SUFDSjtFQXpFTDtJQUFBO0lBQUEsT0EyRUksd0JBQWU7TUFDWCxJQUFJLEtBQUsvQixPQUFULEVBQWtCO1FBQ2QsSUFBTXNCLEtBQUssR0FBR0MsSUFBSSxDQUFDQyxHQUFMLENBQVNDLE1BQU0sQ0FBQ0MsZ0JBQVAsSUFBMkIsQ0FBcEMsRUFBdUMsQ0FBdkMsQ0FBZDtRQUVBLEtBQUsxQixPQUFMLENBQWE2QixLQUFiLEdBQXFCLEtBQUs3QixPQUFMLENBQWFrQyxXQUFiLEdBQTJCWixLQUFoRDtRQUNBLEtBQUt0QixPQUFMLENBQWE4QixNQUFiLEdBQXNCLEtBQUs5QixPQUFMLENBQWFtQyxZQUFiLEdBQTRCYixLQUFsRDtRQUNBLEtBQUt0QixPQUFMLENBQWEyQixVQUFiLENBQXdCLElBQXhCLEVBQThCUyxLQUE5QixDQUFvQ2QsS0FBcEMsRUFBMkNBLEtBQTNDO1FBQ0EsS0FBS2QsWUFBTCxDQUFrQlEsS0FBbEI7TUFDSDtJQUNKO0VBcEZMOztFQUFBO0FBQUE7QUF1RkFTLE1BQU0sQ0FBQ2hDLGVBQVAsR0FBeUJBLGVBQXpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2ZpZWxkcy9zaWduYXR1cmUuanM/M2ZkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldmVudEtleSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcblxuaW1wb3J0IFNpZ25hdHVyZVBhZCBmcm9tICdzaWduYXR1cmVfcGFkJztcblxuZXhwb3J0IGNsYXNzIEZvcm1pZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSkge1xuICAgICAgICB0aGlzLiRmb3JtID0gc2V0dGluZ3MuJGZvcm07XG4gICAgICAgIHRoaXMuZm9ybSA9IHRoaXMuJGZvcm0uZm9ybTtcbiAgICAgICAgdGhpcy4kZmllbGQgPSBzZXR0aW5ncy4kZmllbGQ7XG4gICAgICAgIHRoaXMuJGlucHV0ID0gdGhpcy4kZmllbGQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgdGhpcy4kY2FudmFzID0gdGhpcy4kZmllbGQucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICAgIHRoaXMuJGNsZWFyQnRuID0gdGhpcy4kZmllbGQucXVlcnlTZWxlY3RvcignW2RhdGEtc2lnbmF0dXJlLWNsZWFyXScpO1xuXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB0aGlzLnBlbkNvbG9yID0gc2V0dGluZ3MucGVuQ29sb3I7XG4gICAgICAgIHRoaXMucGVuV2VpZ2h0ID0gc2V0dGluZ3MucGVuV2VpZ2h0O1xuXG4gICAgICAgIGlmICh0aGlzLiRjYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFBhZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGZpbmQgY2FudmFzLicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdFBhZCgpIHtcbiAgICAgICAgdGhpcy5zaWduYXR1cmVQYWQgPSBuZXcgU2lnbmF0dXJlUGFkKHRoaXMuJGNhbnZhcywge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIHBlbkNvbG9yOiB0aGlzLnBlbkNvbG9yLFxuICAgICAgICAgICAgZG90U2l6ZTogdGhpcy5wZW5XZWlnaHQsXG4gICAgICAgICAgICBtaW5XaWR0aDogdGhpcy5wZW5XZWlnaHQsXG4gICAgICAgICAgICBtYXhXaWR0aDogdGhpcy5wZW5XZWlnaHQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2lnbmF0dXJlUGFkLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZFN0cm9rZScsIChlKSA9PiB7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBkYXRhLXVybCBpbWFnZSBmb3IgdGhlIHNlcnZlclxuICAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsdWUgPSB0aGlzLnNpZ25hdHVyZVBhZC50b0RhdGFVUkwoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIGNhbnZhc1xuICAgICAgICBpZiAodGhpcy4kY2xlYXJCdG4pIHtcbiAgICAgICAgICAgIHRoaXMuJGNsZWFyQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlUGFkLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGhpZGRlbiBpbnB1dCBhbHJlYWR5IGhhcyBhIHZhbHVlLCB3ZSBzaG91bGQgdXNlIHRoYXQuIE5vcm1hbGx5IGNhcHR1cmVkXG4gICAgICAgIC8vIGR1cmluZyB2YWxpZGF0aW9uIGVycm9ycywgb3Igd2hlbiBlZGl0aW5nIGFuIGV4aXN0aW5nIHN1Ym1pc3Npb24uXG4gICAgICAgIGlmICh0aGlzLiRpbnB1dC52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgJGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICAgICAgJGltZy5zcmMgPSB0aGlzLiRpbnB1dC52YWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5zaWduYXR1cmVQYWQuY2xlYXIoKTtcblxuICAgICAgICAgICAgJGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHJldGluYSBkZXZpY2VzXG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1heCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLCAxKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuJGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSgkaW1nLCAwLCAwLCB0aGlzLiRjYW52YXMud2lkdGggLyByYXRpbywgdGhpcy4kY2FudmFzLmhlaWdodCAvIHJhdGlvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgcmV0aW5hIGRldmljZXMgdG8gcHJvcGVybHkgc2NhbGUgdGhpbmdzXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUNhbnZhcyk7XG4gICAgICAgIHRoaXMucmVzaXplQ2FudmFzKCk7XG5cbiAgICAgICAgLy8gRm9yIGFqYXggZm9ybXMsIHdlIHdhbnQgdG8gcmVmcmVzaCB0aGUgZmllbGQgd2hlbiB0aGUgcGFnZSBpcyB0b2dnbGVkXG4gICAgICAgIC8vIGZvciBjbGlja2luZyBvbiB0YWJzLCBvciBmb3IgZ29pbmcgdG8gdGhlIG5leHQgcGFnZS4gQ2FudmFzIHNpemUgd2lsbCBiZSB0aW55XG4gICAgICAgIC8vIGlmIGhpZGRlbiAodGhlIGNhc2UgZm9yIG11bHRpLXBhZ2UgZm9ybXMgd2l0aCB0aGlzIGZpZWxkIG9uIGEgbGF0ZXIgcGFnZSkuXG4gICAgICAgIGlmICh0aGlzLmZvcm0uc2V0dGluZ3Muc3VibWl0TWV0aG9kID09PSAnYWpheCcpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMuJGZvcm0sICdvbkZvcm1pZVBhZ2VUb2dnbGUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU3VwcGx5IGEgbGl0dGxlIGRlbGF5IHNvIHRoZSBET00gaXMgcmVhZHlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNpemVDYW52YXMoKSB7XG4gICAgICAgIGlmICh0aGlzLiRjYW52YXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGNhbnZhcy53aWR0aCA9IHRoaXMuJGNhbnZhcy5vZmZzZXRXaWR0aCAqIHJhdGlvO1xuICAgICAgICAgICAgdGhpcy4kY2FudmFzLmhlaWdodCA9IHRoaXMuJGNhbnZhcy5vZmZzZXRIZWlnaHQgKiByYXRpbztcbiAgICAgICAgICAgIHRoaXMuJGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnNjYWxlKHJhdGlvLCByYXRpbyk7XG4gICAgICAgICAgICB0aGlzLnNpZ25hdHVyZVBhZC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG53aW5kb3cuRm9ybWllU2lnbmF0dXJlID0gRm9ybWllU2lnbmF0dXJlO1xuIl0sIm5hbWVzIjpbImV2ZW50S2V5IiwiU2lnbmF0dXJlUGFkIiwiRm9ybWllU2lnbmF0dXJlIiwic2V0dGluZ3MiLCIkZm9ybSIsImZvcm0iLCIkZmllbGQiLCIkaW5wdXQiLCJxdWVyeVNlbGVjdG9yIiwiJGNhbnZhcyIsIiRjbGVhckJ0biIsImJhY2tncm91bmRDb2xvciIsInBlbkNvbG9yIiwicGVuV2VpZ2h0IiwiaW5pdFBhZCIsImNvbnNvbGUiLCJlcnJvciIsInNpZ25hdHVyZVBhZCIsImRvdFNpemUiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJ2YWx1ZSIsInRvRGF0YVVSTCIsImNsZWFyIiwiJGltZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNyYyIsIm9ubG9hZCIsInJhdGlvIiwiTWF0aCIsIm1heCIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwid2lkdGgiLCJoZWlnaHQiLCJyZXNpemVDYW52YXMiLCJzdWJtaXRNZXRob2QiLCJzZXRUaW1lb3V0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJzY2FsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/fields/signature.js\n");

/***/ }),

/***/ "./src/js/utils/utils.js":
/*!*******************************!*\
  !*** ./src/js/utils/utils.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"eventKey\": () => (/* binding */ eventKey),\n/* harmony export */   \"isEmpty\": () => (/* binding */ isEmpty),\n/* harmony export */   \"toBoolean\": () => (/* binding */ toBoolean)\n/* harmony export */ });\nvar isEmpty = function isEmpty(obj) {\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object;\n};\nvar toBoolean = function toBoolean(val) {\n  return !/^(?:f(?:alse)?|no?|0+)$/i.test(val) && !!val;\n};\nvar eventKey = function eventKey(eventName) {\n  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (!namespace) {\n    namespace = Math.random().toString(36).substr(2, 5);\n  }\n\n  return \"\".concat(eventName, \".\").concat(namespace);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvdXRpbHMvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU8sSUFBTUEsT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBU0MsR0FBVCxFQUFjO0VBQ2pDLE9BQU9BLEdBQUcsSUFBSUMsTUFBTSxDQUFDQyxJQUFQLENBQVlGLEdBQVosRUFBaUJHLE1BQWpCLEtBQTRCLENBQW5DLElBQXdDSCxHQUFHLENBQUNJLFdBQUosS0FBb0JILE1BQW5FO0FBQ0gsQ0FGTTtBQUlBLElBQU1JLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQVNDLEdBQVQsRUFBYztFQUNuQyxPQUFPLENBQUMsMkJBQTJCQyxJQUEzQixDQUFnQ0QsR0FBaEMsQ0FBRCxJQUF5QyxDQUFDLENBQUNBLEdBQWxEO0FBQ0gsQ0FGTTtBQUlBLElBQU1FLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVNDLFNBQVQsRUFBc0M7RUFBQSxJQUFsQkMsU0FBa0IsdUVBQU4sSUFBTTs7RUFDMUQsSUFBSSxDQUFDQSxTQUFMLEVBQWdCO0lBQ1pBLFNBQVMsR0FBR0MsSUFBSSxDQUFDQyxNQUFMLEdBQWNDLFFBQWQsQ0FBdUIsRUFBdkIsRUFBMkJDLE1BQTNCLENBQWtDLENBQWxDLEVBQXFDLENBQXJDLENBQVo7RUFDSDs7RUFFRCxpQkFBVUwsU0FBVixjQUF1QkMsU0FBdkI7QUFDSCxDQU5NIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL3V0aWxzLmpzP2Q5ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcblxuZXhwb3J0IGNvbnN0IHRvQm9vbGVhbiA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAhL14oPzpmKD86YWxzZSk/fG5vP3wwKykkL2kudGVzdCh2YWwpICYmICEhdmFsO1xufTtcblxuZXhwb3J0IGNvbnN0IGV2ZW50S2V5ID0gZnVuY3Rpb24oZXZlbnROYW1lLCBuYW1lc3BhY2UgPSBudWxsKSB7XG4gICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDUpO1xuICAgIH1cblxuICAgIHJldHVybiBgJHtldmVudE5hbWV9LiR7bmFtZXNwYWNlfWA7XG59O1xuIl0sIm5hbWVzIjpbImlzRW1wdHkiLCJvYmoiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiY29uc3RydWN0b3IiLCJ0b0Jvb2xlYW4iLCJ2YWwiLCJ0ZXN0IiwiZXZlbnRLZXkiLCJldmVudE5hbWUiLCJuYW1lc3BhY2UiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/utils/utils.js\n");

/***/ }),

/***/ "../../../../node_modules/signature_pad/dist/signature_pad.js":
/*!********************************************************************!*\
  !*** ../../../../node_modules/signature_pad/dist/signature_pad.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SignaturePad)\n/* harmony export */ });\n/*!\n * Signature Pad v4.0.5 | https://github.com/szimek/signature_pad\n * (c) 2022 Szymon Nowak | Released under the MIT license\n */\n\nclass Point {\n    constructor(x, y, pressure, time) {\n        if (isNaN(x) || isNaN(y)) {\n            throw new Error(`Point is invalid: (${x}, ${y})`);\n        }\n        this.x = +x;\n        this.y = +y;\n        this.pressure = pressure || 0;\n        this.time = time || Date.now();\n    }\n    distanceTo(start) {\n        return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n    }\n    equals(other) {\n        return (this.x === other.x &&\n            this.y === other.y &&\n            this.pressure === other.pressure &&\n            this.time === other.time);\n    }\n    velocityFrom(start) {\n        return this.time !== start.time\n            ? this.distanceTo(start) / (this.time - start.time)\n            : 0;\n    }\n}\n\nclass Bezier {\n    constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n        this.startPoint = startPoint;\n        this.control2 = control2;\n        this.control1 = control1;\n        this.endPoint = endPoint;\n        this.startWidth = startWidth;\n        this.endWidth = endWidth;\n    }\n    static fromPoints(points, widths) {\n        const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n        const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n        return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n    }\n    static calculateControlPoints(s1, s2, s3) {\n        const dx1 = s1.x - s2.x;\n        const dy1 = s1.y - s2.y;\n        const dx2 = s2.x - s3.x;\n        const dy2 = s2.y - s3.y;\n        const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n        const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n        const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n        const dxm = m1.x - m2.x;\n        const dym = m1.y - m2.y;\n        const k = l2 / (l1 + l2);\n        const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n        const tx = s2.x - cm.x;\n        const ty = s2.y - cm.y;\n        return {\n            c1: new Point(m1.x + tx, m1.y + ty),\n            c2: new Point(m2.x + tx, m2.y + ty),\n        };\n    }\n    length() {\n        const steps = 10;\n        let length = 0;\n        let px;\n        let py;\n        for (let i = 0; i <= steps; i += 1) {\n            const t = i / steps;\n            const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n            const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n            if (i > 0) {\n                const xdiff = cx - px;\n                const ydiff = cy - py;\n                length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n            }\n            px = cx;\n            py = cy;\n        }\n        return length;\n    }\n    point(t, start, c1, c2, end) {\n        return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))\n            + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)\n            + (3.0 * c2 * (1.0 - t) * t * t)\n            + (end * t * t * t);\n    }\n}\n\nclass SignatureEventTarget {\n    constructor() {\n        try {\n            this._et = new EventTarget();\n        }\n        catch (error) {\n            this._et = document;\n        }\n    }\n    addEventListener(type, listener, options) {\n        this._et.addEventListener(type, listener, options);\n    }\n    dispatchEvent(event) {\n        return this._et.dispatchEvent(event);\n    }\n    removeEventListener(type, callback, options) {\n        this._et.removeEventListener(type, callback, options);\n    }\n}\n\nfunction throttle(fn, wait = 250) {\n    let previous = 0;\n    let timeout = null;\n    let result;\n    let storedContext;\n    let storedArgs;\n    const later = () => {\n        previous = Date.now();\n        timeout = null;\n        result = fn.apply(storedContext, storedArgs);\n        if (!timeout) {\n            storedContext = null;\n            storedArgs = [];\n        }\n    };\n    return function wrapper(...args) {\n        const now = Date.now();\n        const remaining = wait - (now - previous);\n        storedContext = this;\n        storedArgs = args;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = fn.apply(storedContext, storedArgs);\n            if (!timeout) {\n                storedContext = null;\n                storedArgs = [];\n            }\n        }\n        else if (!timeout) {\n            timeout = window.setTimeout(later, remaining);\n        }\n        return result;\n    };\n}\n\nclass SignaturePad extends SignatureEventTarget {\n    constructor(canvas, options = {}) {\n        super();\n        this.canvas = canvas;\n        this._handleMouseDown = (event) => {\n            if (event.buttons === 1) {\n                this._drawningStroke = true;\n                this._strokeBegin(event);\n            }\n        };\n        this._handleMouseMove = (event) => {\n            if (this._drawningStroke) {\n                this._strokeMoveUpdate(event);\n            }\n        };\n        this._handleMouseUp = (event) => {\n            if (event.buttons === 1 && this._drawningStroke) {\n                this._drawningStroke = false;\n                this._strokeEnd(event);\n            }\n        };\n        this._handleTouchStart = (event) => {\n            event.preventDefault();\n            if (event.targetTouches.length === 1) {\n                const touch = event.changedTouches[0];\n                this._strokeBegin(touch);\n            }\n        };\n        this._handleTouchMove = (event) => {\n            event.preventDefault();\n            const touch = event.targetTouches[0];\n            this._strokeMoveUpdate(touch);\n        };\n        this._handleTouchEnd = (event) => {\n            const wasCanvasTouched = event.target === this.canvas;\n            if (wasCanvasTouched) {\n                event.preventDefault();\n                const touch = event.changedTouches[0];\n                this._strokeEnd(touch);\n            }\n        };\n        this._handlePointerStart = (event) => {\n            this._drawningStroke = true;\n            event.preventDefault();\n            this._strokeBegin(event);\n        };\n        this._handlePointerMove = (event) => {\n            if (this._drawningStroke) {\n                event.preventDefault();\n                this._strokeMoveUpdate(event);\n            }\n        };\n        this._handlePointerEnd = (event) => {\n            if (this._drawningStroke) {\n                event.preventDefault();\n                this._drawningStroke = false;\n                this._strokeEnd(event);\n            }\n        };\n        this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n        this.minWidth = options.minWidth || 0.5;\n        this.maxWidth = options.maxWidth || 2.5;\n        this.throttle = ('throttle' in options ? options.throttle : 16);\n        this.minDistance = ('minDistance' in options ? options.minDistance : 5);\n        this.dotSize = options.dotSize || 0;\n        this.penColor = options.penColor || 'black';\n        this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n        this._strokeMoveUpdate = this.throttle\n            ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)\n            : SignaturePad.prototype._strokeUpdate;\n        this._ctx = canvas.getContext('2d');\n        this.clear();\n        this.on();\n    }\n    clear() {\n        const { _ctx: ctx, canvas } = this;\n        ctx.fillStyle = this.backgroundColor;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        this._data = [];\n        this._reset();\n        this._isEmpty = true;\n    }\n    fromDataURL(dataUrl, options = {}) {\n        return new Promise((resolve, reject) => {\n            const image = new Image();\n            const ratio = options.ratio || window.devicePixelRatio || 1;\n            const width = options.width || this.canvas.width / ratio;\n            const height = options.height || this.canvas.height / ratio;\n            const xOffset = options.xOffset || 0;\n            const yOffset = options.yOffset || 0;\n            this._reset();\n            image.onload = () => {\n                this._ctx.drawImage(image, xOffset, yOffset, width, height);\n                resolve();\n            };\n            image.onerror = (error) => {\n                reject(error);\n            };\n            image.crossOrigin = 'anonymous';\n            image.src = dataUrl;\n            this._isEmpty = false;\n        });\n    }\n    toDataURL(type = 'image/png', encoderOptions) {\n        switch (type) {\n            case 'image/svg+xml':\n                return this._toSVG();\n            default:\n                return this.canvas.toDataURL(type, encoderOptions);\n        }\n    }\n    on() {\n        this.canvas.style.touchAction = 'none';\n        this.canvas.style.msTouchAction = 'none';\n        this.canvas.style.userSelect = 'none';\n        const isIOS = /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;\n        if (window.PointerEvent && !isIOS) {\n            this._handlePointerEvents();\n        }\n        else {\n            this._handleMouseEvents();\n            if ('ontouchstart' in window) {\n                this._handleTouchEvents();\n            }\n        }\n    }\n    off() {\n        this.canvas.style.touchAction = 'auto';\n        this.canvas.style.msTouchAction = 'auto';\n        this.canvas.style.userSelect = 'auto';\n        this.canvas.removeEventListener('pointerdown', this._handlePointerStart);\n        this.canvas.removeEventListener('pointermove', this._handlePointerMove);\n        document.removeEventListener('pointerup', this._handlePointerEnd);\n        this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n        this.canvas.removeEventListener('mousemove', this._handleMouseMove);\n        document.removeEventListener('mouseup', this._handleMouseUp);\n        this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n        this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n        this.canvas.removeEventListener('touchend', this._handleTouchEnd);\n    }\n    isEmpty() {\n        return this._isEmpty;\n    }\n    fromData(pointGroups, { clear = true } = {}) {\n        if (clear) {\n            this.clear();\n        }\n        this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));\n        this._data = this._data.concat(pointGroups);\n    }\n    toData() {\n        return this._data;\n    }\n    _strokeBegin(event) {\n        this.dispatchEvent(new CustomEvent('beginStroke', { detail: event }));\n        const newPointGroup = {\n            dotSize: this.dotSize,\n            minWidth: this.minWidth,\n            maxWidth: this.maxWidth,\n            penColor: this.penColor,\n            points: [],\n        };\n        this._data.push(newPointGroup);\n        this._reset();\n        this._strokeUpdate(event);\n    }\n    _strokeUpdate(event) {\n        if (this._data.length === 0) {\n            this._strokeBegin(event);\n            return;\n        }\n        this.dispatchEvent(new CustomEvent('beforeUpdateStroke', { detail: event }));\n        const x = event.clientX;\n        const y = event.clientY;\n        const pressure = event.pressure !== undefined\n            ? event.pressure\n            : event.force !== undefined\n                ? event.force\n                : 0;\n        const point = this._createPoint(x, y, pressure);\n        const lastPointGroup = this._data[this._data.length - 1];\n        const lastPoints = lastPointGroup.points;\n        const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n        const isLastPointTooClose = lastPoint\n            ? point.distanceTo(lastPoint) <= this.minDistance\n            : false;\n        const { penColor, dotSize, minWidth, maxWidth } = lastPointGroup;\n        if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n            const curve = this._addPoint(point);\n            if (!lastPoint) {\n                this._drawDot(point, {\n                    penColor,\n                    dotSize,\n                    minWidth,\n                    maxWidth,\n                });\n            }\n            else if (curve) {\n                this._drawCurve(curve, {\n                    penColor,\n                    dotSize,\n                    minWidth,\n                    maxWidth,\n                });\n            }\n            lastPoints.push({\n                time: point.time,\n                x: point.x,\n                y: point.y,\n                pressure: point.pressure,\n            });\n        }\n        this.dispatchEvent(new CustomEvent('afterUpdateStroke', { detail: event }));\n    }\n    _strokeEnd(event) {\n        this._strokeUpdate(event);\n        this.dispatchEvent(new CustomEvent('endStroke', { detail: event }));\n    }\n    _handlePointerEvents() {\n        this._drawningStroke = false;\n        this.canvas.addEventListener('pointerdown', this._handlePointerStart);\n        this.canvas.addEventListener('pointermove', this._handlePointerMove);\n        document.addEventListener('pointerup', this._handlePointerEnd);\n    }\n    _handleMouseEvents() {\n        this._drawningStroke = false;\n        this.canvas.addEventListener('mousedown', this._handleMouseDown);\n        this.canvas.addEventListener('mousemove', this._handleMouseMove);\n        document.addEventListener('mouseup', this._handleMouseUp);\n    }\n    _handleTouchEvents() {\n        this.canvas.addEventListener('touchstart', this._handleTouchStart);\n        this.canvas.addEventListener('touchmove', this._handleTouchMove);\n        this.canvas.addEventListener('touchend', this._handleTouchEnd);\n    }\n    _reset() {\n        this._lastPoints = [];\n        this._lastVelocity = 0;\n        this._lastWidth = (this.minWidth + this.maxWidth) / 2;\n        this._ctx.fillStyle = this.penColor;\n    }\n    _createPoint(x, y, pressure) {\n        const rect = this.canvas.getBoundingClientRect();\n        return new Point(x - rect.left, y - rect.top, pressure, new Date().getTime());\n    }\n    _addPoint(point) {\n        const { _lastPoints } = this;\n        _lastPoints.push(point);\n        if (_lastPoints.length > 2) {\n            if (_lastPoints.length === 3) {\n                _lastPoints.unshift(_lastPoints[0]);\n            }\n            const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2]);\n            const curve = Bezier.fromPoints(_lastPoints, widths);\n            _lastPoints.shift();\n            return curve;\n        }\n        return null;\n    }\n    _calculateCurveWidths(startPoint, endPoint) {\n        const velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n            (1 - this.velocityFilterWeight) * this._lastVelocity;\n        const newWidth = this._strokeWidth(velocity);\n        const widths = {\n            end: newWidth,\n            start: this._lastWidth,\n        };\n        this._lastVelocity = velocity;\n        this._lastWidth = newWidth;\n        return widths;\n    }\n    _strokeWidth(velocity) {\n        return Math.max(this.maxWidth / (velocity + 1), this.minWidth);\n    }\n    _drawCurveSegment(x, y, width) {\n        const ctx = this._ctx;\n        ctx.moveTo(x, y);\n        ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n        this._isEmpty = false;\n    }\n    _drawCurve(curve, options) {\n        const ctx = this._ctx;\n        const widthDelta = curve.endWidth - curve.startWidth;\n        const drawSteps = Math.ceil(curve.length()) * 2;\n        ctx.beginPath();\n        ctx.fillStyle = options.penColor;\n        for (let i = 0; i < drawSteps; i += 1) {\n            const t = i / drawSteps;\n            const tt = t * t;\n            const ttt = tt * t;\n            const u = 1 - t;\n            const uu = u * u;\n            const uuu = uu * u;\n            let x = uuu * curve.startPoint.x;\n            x += 3 * uu * t * curve.control1.x;\n            x += 3 * u * tt * curve.control2.x;\n            x += ttt * curve.endPoint.x;\n            let y = uuu * curve.startPoint.y;\n            y += 3 * uu * t * curve.control1.y;\n            y += 3 * u * tt * curve.control2.y;\n            y += ttt * curve.endPoint.y;\n            const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);\n            this._drawCurveSegment(x, y, width);\n        }\n        ctx.closePath();\n        ctx.fill();\n    }\n    _drawDot(point, options) {\n        const ctx = this._ctx;\n        const width = options.dotSize > 0\n            ? options.dotSize\n            : (options.minWidth + options.maxWidth) / 2;\n        ctx.beginPath();\n        this._drawCurveSegment(point.x, point.y, width);\n        ctx.closePath();\n        ctx.fillStyle = options.penColor;\n        ctx.fill();\n    }\n    _fromData(pointGroups, drawCurve, drawDot) {\n        for (const group of pointGroups) {\n            const { penColor, dotSize, minWidth, maxWidth, points } = group;\n            if (points.length > 1) {\n                for (let j = 0; j < points.length; j += 1) {\n                    const basicPoint = points[j];\n                    const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);\n                    this.penColor = penColor;\n                    if (j === 0) {\n                        this._reset();\n                    }\n                    const curve = this._addPoint(point);\n                    if (curve) {\n                        drawCurve(curve, {\n                            penColor,\n                            dotSize,\n                            minWidth,\n                            maxWidth,\n                        });\n                    }\n                }\n            }\n            else {\n                this._reset();\n                drawDot(points[0], {\n                    penColor,\n                    dotSize,\n                    minWidth,\n                    maxWidth,\n                });\n            }\n        }\n    }\n    _toSVG() {\n        const pointGroups = this._data;\n        const ratio = Math.max(window.devicePixelRatio || 1, 1);\n        const minX = 0;\n        const minY = 0;\n        const maxX = this.canvas.width / ratio;\n        const maxY = this.canvas.height / ratio;\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.setAttribute('width', this.canvas.width.toString());\n        svg.setAttribute('height', this.canvas.height.toString());\n        this._fromData(pointGroups, (curve, { penColor }) => {\n            const path = document.createElement('path');\n            if (!isNaN(curve.control1.x) &&\n                !isNaN(curve.control1.y) &&\n                !isNaN(curve.control2.x) &&\n                !isNaN(curve.control2.y)) {\n                const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} ` +\n                    `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +\n                    `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +\n                    `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n                path.setAttribute('d', attr);\n                path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n                path.setAttribute('stroke', penColor);\n                path.setAttribute('fill', 'none');\n                path.setAttribute('stroke-linecap', 'round');\n                svg.appendChild(path);\n            }\n        }, (point, { penColor, dotSize, minWidth, maxWidth }) => {\n            const circle = document.createElement('circle');\n            const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;\n            circle.setAttribute('r', size.toString());\n            circle.setAttribute('cx', point.x.toString());\n            circle.setAttribute('cy', point.y.toString());\n            circle.setAttribute('fill', penColor);\n            svg.appendChild(circle);\n        });\n        const prefix = 'data:image/svg+xml;base64,';\n        const header = '<svg' +\n            ' xmlns=\"http://www.w3.org/2000/svg\"' +\n            ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"' +\n            ` viewBox=\"${minX} ${minY} ${this.canvas.width} ${this.canvas.height}\"` +\n            ` width=\"${maxX}\"` +\n            ` height=\"${maxY}\"` +\n            '>';\n        let body = svg.innerHTML;\n        if (body === undefined) {\n            const dummy = document.createElement('dummy');\n            const nodes = svg.childNodes;\n            dummy.innerHTML = '';\n            for (let i = 0; i < nodes.length; i += 1) {\n                dummy.appendChild(nodes[i].cloneNode(true));\n            }\n            body = dummy.innerHTML;\n        }\n        const footer = '</svg>';\n        const data = header + body + footer;\n        return prefix + btoa(data);\n    }\n}\n\n\n//# sourceMappingURL=signature_pad.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NpZ25hdHVyZV9wYWQvZGlzdC9zaWduYXR1cmVfcGFkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRSxJQUFJLEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZSxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGVBQWU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZUFBZTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtFQUFrRSxlQUFlO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxlQUFlO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQWdEO0FBQ3BFO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCLEdBQUcsK0JBQStCO0FBQ2xHLHlCQUF5Qiw0QkFBNEIsR0FBRyw2QkFBNkI7QUFDckYsdUJBQXVCLDRCQUE0QixHQUFHLDZCQUE2QjtBQUNuRix1QkFBdUIsNEJBQTRCLEdBQUcsNEJBQTRCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZLHVDQUF1QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU0sRUFBRSxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsbUJBQW1CO0FBQ2pGLHVCQUF1QixLQUFLO0FBQzVCLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2lnbmF0dXJlX3BhZC9kaXN0L3NpZ25hdHVyZV9wYWQuanM/ODVmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFNpZ25hdHVyZSBQYWQgdjQuMC41IHwgaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9zaWduYXR1cmVfcGFkXG4gKiAoYykgMjAyMiBTenltb24gTm93YWsgfCBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5jbGFzcyBQb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgcHJlc3N1cmUsIHRpbWUpIHtcbiAgICAgICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IGlzIGludmFsaWQ6ICgke3h9LCAke3l9KWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueCA9ICt4O1xuICAgICAgICB0aGlzLnkgPSAreTtcbiAgICAgICAgdGhpcy5wcmVzc3VyZSA9IHByZXNzdXJlIHx8IDA7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWUgfHwgRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgZGlzdGFuY2VUbyhzdGFydCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueCAtIHN0YXJ0LngsIDIpICsgTWF0aC5wb3codGhpcy55IC0gc3RhcnQueSwgMikpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnggPT09IG90aGVyLnggJiZcbiAgICAgICAgICAgIHRoaXMueSA9PT0gb3RoZXIueSAmJlxuICAgICAgICAgICAgdGhpcy5wcmVzc3VyZSA9PT0gb3RoZXIucHJlc3N1cmUgJiZcbiAgICAgICAgICAgIHRoaXMudGltZSA9PT0gb3RoZXIudGltZSk7XG4gICAgfVxuICAgIHZlbG9jaXR5RnJvbShzdGFydCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lICE9PSBzdGFydC50aW1lXG4gICAgICAgICAgICA/IHRoaXMuZGlzdGFuY2VUbyhzdGFydCkgLyAodGhpcy50aW1lIC0gc3RhcnQudGltZSlcbiAgICAgICAgICAgIDogMDtcbiAgICB9XG59XG5cbmNsYXNzIEJlemllciB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnRQb2ludCwgY29udHJvbDIsIGNvbnRyb2wxLCBlbmRQb2ludCwgc3RhcnRXaWR0aCwgZW5kV2lkdGgpIHtcbiAgICAgICAgdGhpcy5zdGFydFBvaW50ID0gc3RhcnRQb2ludDtcbiAgICAgICAgdGhpcy5jb250cm9sMiA9IGNvbnRyb2wyO1xuICAgICAgICB0aGlzLmNvbnRyb2wxID0gY29udHJvbDE7XG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSBlbmRQb2ludDtcbiAgICAgICAgdGhpcy5zdGFydFdpZHRoID0gc3RhcnRXaWR0aDtcbiAgICAgICAgdGhpcy5lbmRXaWR0aCA9IGVuZFdpZHRoO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVBvaW50cyhwb2ludHMsIHdpZHRocykge1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuY2FsY3VsYXRlQ29udHJvbFBvaW50cyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdKS5jMjtcbiAgICAgICAgY29uc3QgYzMgPSB0aGlzLmNhbGN1bGF0ZUNvbnRyb2xQb2ludHMocG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSkuYzE7XG4gICAgICAgIHJldHVybiBuZXcgQmV6aWVyKHBvaW50c1sxXSwgYzIsIGMzLCBwb2ludHNbMl0sIHdpZHRocy5zdGFydCwgd2lkdGhzLmVuZCk7XG4gICAgfVxuICAgIHN0YXRpYyBjYWxjdWxhdGVDb250cm9sUG9pbnRzKHMxLCBzMiwgczMpIHtcbiAgICAgICAgY29uc3QgZHgxID0gczEueCAtIHMyLng7XG4gICAgICAgIGNvbnN0IGR5MSA9IHMxLnkgLSBzMi55O1xuICAgICAgICBjb25zdCBkeDIgPSBzMi54IC0gczMueDtcbiAgICAgICAgY29uc3QgZHkyID0gczIueSAtIHMzLnk7XG4gICAgICAgIGNvbnN0IG0xID0geyB4OiAoczEueCArIHMyLngpIC8gMi4wLCB5OiAoczEueSArIHMyLnkpIC8gMi4wIH07XG4gICAgICAgIGNvbnN0IG0yID0geyB4OiAoczIueCArIHMzLngpIC8gMi4wLCB5OiAoczIueSArIHMzLnkpIC8gMi4wIH07XG4gICAgICAgIGNvbnN0IGwxID0gTWF0aC5zcXJ0KGR4MSAqIGR4MSArIGR5MSAqIGR5MSk7XG4gICAgICAgIGNvbnN0IGwyID0gTWF0aC5zcXJ0KGR4MiAqIGR4MiArIGR5MiAqIGR5Mik7XG4gICAgICAgIGNvbnN0IGR4bSA9IG0xLnggLSBtMi54O1xuICAgICAgICBjb25zdCBkeW0gPSBtMS55IC0gbTIueTtcbiAgICAgICAgY29uc3QgayA9IGwyIC8gKGwxICsgbDIpO1xuICAgICAgICBjb25zdCBjbSA9IHsgeDogbTIueCArIGR4bSAqIGssIHk6IG0yLnkgKyBkeW0gKiBrIH07XG4gICAgICAgIGNvbnN0IHR4ID0gczIueCAtIGNtLng7XG4gICAgICAgIGNvbnN0IHR5ID0gczIueSAtIGNtLnk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMTogbmV3IFBvaW50KG0xLnggKyB0eCwgbTEueSArIHR5KSxcbiAgICAgICAgICAgIGMyOiBuZXcgUG9pbnQobTIueCArIHR4LCBtMi55ICsgdHkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IHN0ZXBzID0gMTA7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICBsZXQgcHg7XG4gICAgICAgIGxldCBweTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc3RlcHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgdCA9IGkgLyBzdGVwcztcbiAgICAgICAgICAgIGNvbnN0IGN4ID0gdGhpcy5wb2ludCh0LCB0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5jb250cm9sMS54LCB0aGlzLmNvbnRyb2wyLngsIHRoaXMuZW5kUG9pbnQueCk7XG4gICAgICAgICAgICBjb25zdCBjeSA9IHRoaXMucG9pbnQodCwgdGhpcy5zdGFydFBvaW50LnksIHRoaXMuY29udHJvbDEueSwgdGhpcy5jb250cm9sMi55LCB0aGlzLmVuZFBvaW50LnkpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeGRpZmYgPSBjeCAtIHB4O1xuICAgICAgICAgICAgICAgIGNvbnN0IHlkaWZmID0gY3kgLSBweTtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gTWF0aC5zcXJ0KHhkaWZmICogeGRpZmYgKyB5ZGlmZiAqIHlkaWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHB4ID0gY3g7XG4gICAgICAgICAgICBweSA9IGN5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIHBvaW50KHQsIHN0YXJ0LCBjMSwgYzIsIGVuZCkge1xuICAgICAgICByZXR1cm4gKHN0YXJ0ICogKDEuMCAtIHQpICogKDEuMCAtIHQpICogKDEuMCAtIHQpKVxuICAgICAgICAgICAgKyAoMy4wICogYzEgKiAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgKiB0KVxuICAgICAgICAgICAgKyAoMy4wICogYzIgKiAoMS4wIC0gdCkgKiB0ICogdClcbiAgICAgICAgICAgICsgKGVuZCAqIHQgKiB0ICogdCk7XG4gICAgfVxufVxuXG5jbGFzcyBTaWduYXR1cmVFdmVudFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9ldCA9IG5ldyBFdmVudFRhcmdldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fZXQgPSBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9ldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCB3YWl0ID0gMjUwKSB7XG4gICAgbGV0IHByZXZpb3VzID0gMDtcbiAgICBsZXQgdGltZW91dCA9IG51bGw7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgc3RvcmVkQ29udGV4dDtcbiAgICBsZXQgc3RvcmVkQXJncztcbiAgICBjb25zdCBsYXRlciA9ICgpID0+IHtcbiAgICAgICAgcHJldmlvdXMgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gZm4uYXBwbHkoc3RvcmVkQ29udGV4dCwgc3RvcmVkQXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgc3RvcmVkQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICBzdG9yZWRBcmdzID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiB3cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgIHN0b3JlZENvbnRleHQgPSB0aGlzO1xuICAgICAgICBzdG9yZWRBcmdzID0gYXJncztcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICByZXN1bHQgPSBmbi5hcHBseShzdG9yZWRDb250ZXh0LCBzdG9yZWRBcmdzKTtcbiAgICAgICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgICAgIHN0b3JlZENvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0b3JlZEFyZ3MgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxuY2xhc3MgU2lnbmF0dXJlUGFkIGV4dGVuZHMgU2lnbmF0dXJlRXZlbnRUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLl9oYW5kbGVNb3VzZURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5idXR0b25zID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd25pbmdTdHJva2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZUJlZ2luKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd25pbmdTdHJva2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VNb3ZlVXBkYXRlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VVcCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT09IDEgJiYgdGhpcy5fZHJhd25pbmdTdHJva2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3bmluZ1N0cm9rZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZUVuZChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZUJlZ2luKHRvdWNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faGFuZGxlVG91Y2hNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50YXJnZXRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlTW92ZVVwZGF0ZSh0b3VjaCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hhbmRsZVRvdWNoRW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3YXNDYW52YXNUb3VjaGVkID0gZXZlbnQudGFyZ2V0ID09PSB0aGlzLmNhbnZhcztcbiAgICAgICAgICAgIGlmICh3YXNDYW52YXNUb3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZUVuZCh0b3VjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hhbmRsZVBvaW50ZXJTdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZHJhd25pbmdTdHJva2UgPSB0cnVlO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZUJlZ2luKGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faGFuZGxlUG9pbnRlck1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3bmluZ1N0cm9rZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Ryb2tlTW92ZVVwZGF0ZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hhbmRsZVBvaW50ZXJFbmQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3bmluZ1N0cm9rZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd25pbmdTdHJva2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VFbmQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnZlbG9jaXR5RmlsdGVyV2VpZ2h0ID0gb3B0aW9ucy52ZWxvY2l0eUZpbHRlcldlaWdodCB8fCAwLjc7XG4gICAgICAgIHRoaXMubWluV2lkdGggPSBvcHRpb25zLm1pbldpZHRoIHx8IDAuNTtcbiAgICAgICAgdGhpcy5tYXhXaWR0aCA9IG9wdGlvbnMubWF4V2lkdGggfHwgMi41O1xuICAgICAgICB0aGlzLnRocm90dGxlID0gKCd0aHJvdHRsZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGhyb3R0bGUgOiAxNik7XG4gICAgICAgIHRoaXMubWluRGlzdGFuY2UgPSAoJ21pbkRpc3RhbmNlJyBpbiBvcHRpb25zID8gb3B0aW9ucy5taW5EaXN0YW5jZSA6IDUpO1xuICAgICAgICB0aGlzLmRvdFNpemUgPSBvcHRpb25zLmRvdFNpemUgfHwgMDtcbiAgICAgICAgdGhpcy5wZW5Db2xvciA9IG9wdGlvbnMucGVuQ29sb3IgfHwgJ2JsYWNrJztcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvciB8fCAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIHRoaXMuX3N0cm9rZU1vdmVVcGRhdGUgPSB0aGlzLnRocm90dGxlXG4gICAgICAgICAgICA/IHRocm90dGxlKFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZVVwZGF0ZSwgdGhpcy50aHJvdHRsZSlcbiAgICAgICAgICAgIDogU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlVXBkYXRlO1xuICAgICAgICB0aGlzLl9jdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLm9uKCk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBjb25zdCB7IF9jdHg6IGN0eCwgY2FudmFzIH0gPSB0aGlzO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgdGhpcy5faXNFbXB0eSA9IHRydWU7XG4gICAgfVxuICAgIGZyb21EYXRhVVJMKGRhdGFVcmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gb3B0aW9ucy5yYXRpbyB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IHRoaXMuY2FudmFzLndpZHRoIC8gcmF0aW87XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCB0aGlzLmNhbnZhcy5oZWlnaHQgLyByYXRpbztcbiAgICAgICAgICAgIGNvbnN0IHhPZmZzZXQgPSBvcHRpb25zLnhPZmZzZXQgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHlPZmZzZXQgPSBvcHRpb25zLnlPZmZzZXQgfHwgMDtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LmRyYXdJbWFnZShpbWFnZSwgeE9mZnNldCwgeU9mZnNldCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICAgICAgICBpbWFnZS5zcmMgPSBkYXRhVXJsO1xuICAgICAgICAgICAgdGhpcy5faXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9EYXRhVVJMKHR5cGUgPSAnaW1hZ2UvcG5nJywgZW5jb2Rlck9wdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdpbWFnZS9zdmcreG1sJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9TVkcoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCh0eXBlLCBlbmNvZGVyT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBjb25zdCBpc0lPUyA9IC9NYWNpbnRvc2gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQ7XG4gICAgICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50ICYmICFpc0lPUykge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlTW91c2VFdmVudHMoKTtcbiAgICAgICAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9mZigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG91Y2hBY3Rpb24gPSAnYXV0byc7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSAnYXV0byc7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnVzZXJTZWxlY3QgPSAnYXV0byc7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5faGFuZGxlUG9pbnRlclN0YXJ0KTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVQb2ludGVyTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFbmQpO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9oYW5kbGVNb3VzZURvd24pO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlTW91c2VVcCk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVUb3VjaEVuZCk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0VtcHR5O1xuICAgIH1cbiAgICBmcm9tRGF0YShwb2ludEdyb3VwcywgeyBjbGVhciA9IHRydWUgfSA9IHt9KSB7XG4gICAgICAgIGlmIChjbGVhcikge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Zyb21EYXRhKHBvaW50R3JvdXBzLCB0aGlzLl9kcmF3Q3VydmUuYmluZCh0aGlzKSwgdGhpcy5fZHJhd0RvdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGEuY29uY2F0KHBvaW50R3JvdXBzKTtcbiAgICB9XG4gICAgdG9EYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG4gICAgX3N0cm9rZUJlZ2luKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2JlZ2luU3Ryb2tlJywgeyBkZXRhaWw6IGV2ZW50IH0pKTtcbiAgICAgICAgY29uc3QgbmV3UG9pbnRHcm91cCA9IHtcbiAgICAgICAgICAgIGRvdFNpemU6IHRoaXMuZG90U2l6ZSxcbiAgICAgICAgICAgIG1pbldpZHRoOiB0aGlzLm1pbldpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGg6IHRoaXMubWF4V2lkdGgsXG4gICAgICAgICAgICBwZW5Db2xvcjogdGhpcy5wZW5Db2xvcixcbiAgICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RhdGEucHVzaChuZXdQb2ludEdyb3VwKTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgdGhpcy5fc3Ryb2tlVXBkYXRlKGV2ZW50KTtcbiAgICB9XG4gICAgX3N0cm9rZVVwZGF0ZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZUJlZ2luKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdiZWZvcmVVcGRhdGVTdHJva2UnLCB7IGRldGFpbDogZXZlbnQgfSkpO1xuICAgICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGNvbnN0IHByZXNzdXJlID0gZXZlbnQucHJlc3N1cmUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBldmVudC5wcmVzc3VyZVxuICAgICAgICAgICAgOiBldmVudC5mb3JjZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBldmVudC5mb3JjZVxuICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLl9jcmVhdGVQb2ludCh4LCB5LCBwcmVzc3VyZSk7XG4gICAgICAgIGNvbnN0IGxhc3RQb2ludEdyb3VwID0gdGhpcy5fZGF0YVt0aGlzLl9kYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBsYXN0UG9pbnRzID0gbGFzdFBvaW50R3JvdXAucG9pbnRzO1xuICAgICAgICBjb25zdCBsYXN0UG9pbnQgPSBsYXN0UG9pbnRzLmxlbmd0aCA+IDAgJiYgbGFzdFBvaW50c1tsYXN0UG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBpc0xhc3RQb2ludFRvb0Nsb3NlID0gbGFzdFBvaW50XG4gICAgICAgICAgICA/IHBvaW50LmRpc3RhbmNlVG8obGFzdFBvaW50KSA8PSB0aGlzLm1pbkRpc3RhbmNlXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICBjb25zdCB7IHBlbkNvbG9yLCBkb3RTaXplLCBtaW5XaWR0aCwgbWF4V2lkdGggfSA9IGxhc3RQb2ludEdyb3VwO1xuICAgICAgICBpZiAoIWxhc3RQb2ludCB8fCAhKGxhc3RQb2ludCAmJiBpc0xhc3RQb2ludFRvb0Nsb3NlKSkge1xuICAgICAgICAgICAgY29uc3QgY3VydmUgPSB0aGlzLl9hZGRQb2ludChwb2ludCk7XG4gICAgICAgICAgICBpZiAoIWxhc3RQb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdEb3QocG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGRvdFNpemUsXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd0N1cnZlKGN1cnZlLCB7XG4gICAgICAgICAgICAgICAgICAgIHBlbkNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBkb3RTaXplLFxuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0UG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpbWU6IHBvaW50LnRpbWUsXG4gICAgICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55LFxuICAgICAgICAgICAgICAgIHByZXNzdXJlOiBwb2ludC5wcmVzc3VyZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2FmdGVyVXBkYXRlU3Ryb2tlJywgeyBkZXRhaWw6IGV2ZW50IH0pKTtcbiAgICB9XG4gICAgX3N0cm9rZUVuZChldmVudCkge1xuICAgICAgICB0aGlzLl9zdHJva2VVcGRhdGUoZXZlbnQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdlbmRTdHJva2UnLCB7IGRldGFpbDogZXZlbnQgfSkpO1xuICAgIH1cbiAgICBfaGFuZGxlUG9pbnRlckV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5fZHJhd25pbmdTdHJva2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLl9oYW5kbGVQb2ludGVyU3RhcnQpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5faGFuZGxlUG9pbnRlckVuZCk7XG4gICAgfVxuICAgIF9oYW5kbGVNb3VzZUV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5fZHJhd25pbmdTdHJva2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZU1vdXNlVXApO1xuICAgIH1cbiAgICBfaGFuZGxlVG91Y2hFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVUb3VjaEVuZCk7XG4gICAgfVxuICAgIF9yZXNldCgpIHtcbiAgICAgICAgdGhpcy5fbGFzdFBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9sYXN0VmVsb2NpdHkgPSAwO1xuICAgICAgICB0aGlzLl9sYXN0V2lkdGggPSAodGhpcy5taW5XaWR0aCArIHRoaXMubWF4V2lkdGgpIC8gMjtcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxTdHlsZSA9IHRoaXMucGVuQ29sb3I7XG4gICAgfVxuICAgIF9jcmVhdGVQb2ludCh4LCB5LCBwcmVzc3VyZSkge1xuICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCAtIHJlY3QubGVmdCwgeSAtIHJlY3QudG9wLCBwcmVzc3VyZSwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICBfYWRkUG9pbnQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgeyBfbGFzdFBvaW50cyB9ID0gdGhpcztcbiAgICAgICAgX2xhc3RQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgIGlmIChfbGFzdFBvaW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBpZiAoX2xhc3RQb2ludHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgX2xhc3RQb2ludHMudW5zaGlmdChfbGFzdFBvaW50c1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3aWR0aHMgPSB0aGlzLl9jYWxjdWxhdGVDdXJ2ZVdpZHRocyhfbGFzdFBvaW50c1sxXSwgX2xhc3RQb2ludHNbMl0pO1xuICAgICAgICAgICAgY29uc3QgY3VydmUgPSBCZXppZXIuZnJvbVBvaW50cyhfbGFzdFBvaW50cywgd2lkdGhzKTtcbiAgICAgICAgICAgIF9sYXN0UG9pbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXR1cm4gY3VydmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9jYWxjdWxhdGVDdXJ2ZVdpZHRocyhzdGFydFBvaW50LCBlbmRQb2ludCkge1xuICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHlGaWx0ZXJXZWlnaHQgKiBlbmRQb2ludC52ZWxvY2l0eUZyb20oc3RhcnRQb2ludCkgK1xuICAgICAgICAgICAgKDEgLSB0aGlzLnZlbG9jaXR5RmlsdGVyV2VpZ2h0KSAqIHRoaXMuX2xhc3RWZWxvY2l0eTtcbiAgICAgICAgY29uc3QgbmV3V2lkdGggPSB0aGlzLl9zdHJva2VXaWR0aCh2ZWxvY2l0eSk7XG4gICAgICAgIGNvbnN0IHdpZHRocyA9IHtcbiAgICAgICAgICAgIGVuZDogbmV3V2lkdGgsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5fbGFzdFdpZHRoLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9sYXN0VmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICAgICAgdGhpcy5fbGFzdFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgIHJldHVybiB3aWR0aHM7XG4gICAgfVxuICAgIF9zdHJva2VXaWR0aCh2ZWxvY2l0eSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5tYXhXaWR0aCAvICh2ZWxvY2l0eSArIDEpLCB0aGlzLm1pbldpZHRoKTtcbiAgICB9XG4gICAgX2RyYXdDdXJ2ZVNlZ21lbnQoeCwgeSwgd2lkdGgpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICBjdHguYXJjKHgsIHksIHdpZHRoLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9pc0VtcHR5ID0gZmFsc2U7XG4gICAgfVxuICAgIF9kcmF3Q3VydmUoY3VydmUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBjb25zdCB3aWR0aERlbHRhID0gY3VydmUuZW5kV2lkdGggLSBjdXJ2ZS5zdGFydFdpZHRoO1xuICAgICAgICBjb25zdCBkcmF3U3RlcHMgPSBNYXRoLmNlaWwoY3VydmUubGVuZ3RoKCkpICogMjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5wZW5Db2xvcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmF3U3RlcHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgdCA9IGkgLyBkcmF3U3RlcHM7XG4gICAgICAgICAgICBjb25zdCB0dCA9IHQgKiB0O1xuICAgICAgICAgICAgY29uc3QgdHR0ID0gdHQgKiB0O1xuICAgICAgICAgICAgY29uc3QgdSA9IDEgLSB0O1xuICAgICAgICAgICAgY29uc3QgdXUgPSB1ICogdTtcbiAgICAgICAgICAgIGNvbnN0IHV1dSA9IHV1ICogdTtcbiAgICAgICAgICAgIGxldCB4ID0gdXV1ICogY3VydmUuc3RhcnRQb2ludC54O1xuICAgICAgICAgICAgeCArPSAzICogdXUgKiB0ICogY3VydmUuY29udHJvbDEueDtcbiAgICAgICAgICAgIHggKz0gMyAqIHUgKiB0dCAqIGN1cnZlLmNvbnRyb2wyLng7XG4gICAgICAgICAgICB4ICs9IHR0dCAqIGN1cnZlLmVuZFBvaW50Lng7XG4gICAgICAgICAgICBsZXQgeSA9IHV1dSAqIGN1cnZlLnN0YXJ0UG9pbnQueTtcbiAgICAgICAgICAgIHkgKz0gMyAqIHV1ICogdCAqIGN1cnZlLmNvbnRyb2wxLnk7XG4gICAgICAgICAgICB5ICs9IDMgKiB1ICogdHQgKiBjdXJ2ZS5jb250cm9sMi55O1xuICAgICAgICAgICAgeSArPSB0dHQgKiBjdXJ2ZS5lbmRQb2ludC55O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihjdXJ2ZS5zdGFydFdpZHRoICsgdHR0ICogd2lkdGhEZWx0YSwgb3B0aW9ucy5tYXhXaWR0aCk7XG4gICAgICAgICAgICB0aGlzLl9kcmF3Q3VydmVTZWdtZW50KHgsIHksIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIF9kcmF3RG90KHBvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBvcHRpb25zLmRvdFNpemUgPiAwXG4gICAgICAgICAgICA/IG9wdGlvbnMuZG90U2l6ZVxuICAgICAgICAgICAgOiAob3B0aW9ucy5taW5XaWR0aCArIG9wdGlvbnMubWF4V2lkdGgpIC8gMjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9kcmF3Q3VydmVTZWdtZW50KHBvaW50LngsIHBvaW50LnksIHdpZHRoKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5wZW5Db2xvcjtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgX2Zyb21EYXRhKHBvaW50R3JvdXBzLCBkcmF3Q3VydmUsIGRyYXdEb3QpIHtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBwb2ludEdyb3Vwcykge1xuICAgICAgICAgICAgY29uc3QgeyBwZW5Db2xvciwgZG90U2l6ZSwgbWluV2lkdGgsIG1heFdpZHRoLCBwb2ludHMgfSA9IGdyb3VwO1xuICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzaWNQb2ludCA9IHBvaW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoYmFzaWNQb2ludC54LCBiYXNpY1BvaW50LnksIGJhc2ljUG9pbnQucHJlc3N1cmUsIGJhc2ljUG9pbnQudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuQ29sb3IgPSBwZW5Db2xvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VydmUgPSB0aGlzLl9hZGRQb2ludChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0N1cnZlKGN1cnZlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgICAgICAgICBkcmF3RG90KHBvaW50c1swXSwge1xuICAgICAgICAgICAgICAgICAgICBwZW5Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgZG90U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF90b1NWRygpIHtcbiAgICAgICAgY29uc3QgcG9pbnRHcm91cHMgPSB0aGlzLl9kYXRhO1xuICAgICAgICBjb25zdCByYXRpbyA9IE1hdGgubWF4KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDEpO1xuICAgICAgICBjb25zdCBtaW5YID0gMDtcbiAgICAgICAgY29uc3QgbWluWSA9IDA7XG4gICAgICAgIGNvbnN0IG1heFggPSB0aGlzLmNhbnZhcy53aWR0aCAvIHJhdGlvO1xuICAgICAgICBjb25zdCBtYXhZID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gcmF0aW87XG4gICAgICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5jYW52YXMud2lkdGgudG9TdHJpbmcoKSk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuY2FudmFzLmhlaWdodC50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5fZnJvbURhdGEocG9pbnRHcm91cHMsIChjdXJ2ZSwgeyBwZW5Db2xvciB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGF0aCcpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihjdXJ2ZS5jb250cm9sMS54KSAmJlxuICAgICAgICAgICAgICAgICFpc05hTihjdXJ2ZS5jb250cm9sMS55KSAmJlxuICAgICAgICAgICAgICAgICFpc05hTihjdXJ2ZS5jb250cm9sMi54KSAmJlxuICAgICAgICAgICAgICAgICFpc05hTihjdXJ2ZS5jb250cm9sMi55KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBgTSAke2N1cnZlLnN0YXJ0UG9pbnQueC50b0ZpeGVkKDMpfSwke2N1cnZlLnN0YXJ0UG9pbnQueS50b0ZpeGVkKDMpfSBgICtcbiAgICAgICAgICAgICAgICAgICAgYEMgJHtjdXJ2ZS5jb250cm9sMS54LnRvRml4ZWQoMyl9LCR7Y3VydmUuY29udHJvbDEueS50b0ZpeGVkKDMpfSBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7Y3VydmUuY29udHJvbDIueC50b0ZpeGVkKDMpfSwke2N1cnZlLmNvbnRyb2wyLnkudG9GaXhlZCgzKX0gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke2N1cnZlLmVuZFBvaW50LngudG9GaXhlZCgzKX0sJHtjdXJ2ZS5lbmRQb2ludC55LnRvRml4ZWQoMyl9YDtcbiAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIGF0dHIpO1xuICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCAoY3VydmUuZW5kV2lkdGggKiAyLjI1KS50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgcGVuQ29sb3IpO1xuICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKTtcbiAgICAgICAgICAgICAgICBzdmcuYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChwb2ludCwgeyBwZW5Db2xvciwgZG90U2l6ZSwgbWluV2lkdGgsIG1heFdpZHRoIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NpcmNsZScpO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGRvdFNpemUgPiAwID8gZG90U2l6ZSA6IChtaW5XaWR0aCArIG1heFdpZHRoKSAvIDI7XG4gICAgICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdyJywgc2l6ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N4JywgcG9pbnQueC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N5JywgcG9pbnQueS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBwZW5Db2xvcik7XG4gICAgICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoY2lyY2xlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCc7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9ICc8c3ZnJyArXG4gICAgICAgICAgICAnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIicgK1xuICAgICAgICAgICAgJyB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIicgK1xuICAgICAgICAgICAgYCB2aWV3Qm94PVwiJHttaW5YfSAke21pbll9ICR7dGhpcy5jYW52YXMud2lkdGh9ICR7dGhpcy5jYW52YXMuaGVpZ2h0fVwiYCArXG4gICAgICAgICAgICBgIHdpZHRoPVwiJHttYXhYfVwiYCArXG4gICAgICAgICAgICBgIGhlaWdodD1cIiR7bWF4WX1cImAgK1xuICAgICAgICAgICAgJz4nO1xuICAgICAgICBsZXQgYm9keSA9IHN2Zy5pbm5lckhUTUw7XG4gICAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZHVtbXknKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gc3ZnLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBkdW1teS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBkdW1teS5hcHBlbmRDaGlsZChub2Rlc1tpXS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keSA9IGR1bW15LmlubmVySFRNTDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb290ZXIgPSAnPC9zdmc+JztcbiAgICAgICAgY29uc3QgZGF0YSA9IGhlYWRlciArIGJvZHkgKyBmb290ZXI7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyBidG9hKGRhdGEpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgU2lnbmF0dXJlUGFkIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZV9wYWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../../node_modules/signature_pad/dist/signature_pad.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/fields/signature.js");
/******/ 	
/******/ })()
;